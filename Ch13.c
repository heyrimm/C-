// 포인터
// 1. 포인터를 사용해야하는 이유
// 1.1 : 메모리의 주소를 참조해서 다양한 접근과 조작이 쉽다.
// 1.2 : 동적 할당된 (힙영역)에 접근과 조작이 용이
// 1.3 : 메모리 공간을 효율적으로 사용

// 1. 메모리의 주소를 사용하는 변수다.(메모리의 내용에 직접 접근할 수 있다.)
// 2. 변수는 메모리에 저장된다. 메모리는 바이트 단위로 액세스 된다.
// 3. 변수의 크기에 따라 차지하는 메모리 공간이 달라진다. 

// 2) 변수의 주소
//
// 변수 : 메모리 상의 저장공간. 그 위치를 알면 사용이 가능하다.

// 위치값 - 주소

// 변수의 주소를 계산하는 연산자 : & (참조 연산자, 주소 연산자)
// 변수 i의 주소 : &i

// 자바에서
// 원시 타입 = int, boolean, char
// 참조 타입 = String, integer
// 

//#include<stdio.h>
//int main()
//{
//	int i = 10;
//	char c = 69;
//	float f = 12.3;
//	//%p : 16진법
//	printf("i의 주소 : %p\n", &i);
//	printf("c의 주소 : %p\n", &c);
//	printf("f의 주소 : %p\n", &f);
//}

// 포인터와 연산자

// 주소 연산자 : int a;      &a 
// 기능 : 변수 앞에 붙여 사용하면 변수가 할당된 메모리의 시작 주소값을 구한다. 
// int a = 10;      : 메모리 안에서는 100번지 ~ 103번지까지 4바이트 공간에 10을 저장
// a + 20           : 메모리 100번지 ~ 103번지까지 4바이트에 저장된 값과 20을 더하는 연산 수행
// 결론 : 변수명으로 메모리 공간이나 값을 간단히 사용 가능

// 변수의 크기, 메모리 할당 방식
// 컴파일러(컴퓨터), 운영체제에 따라 다를 수 있다. 

// 포인터 : char* pc; int* pi, double* pd;  
// 기능 : 시작 주소값을 저장하는 변수며, 가리키는 자료형을 표시하여 선언한다.

// 간접참조 연산자 : *pi = 10; 
// 기능 : 포인터에 사용하며, 포인터가 가리키는 변수를 사용한다. 

// *의 의미 : 
// 1. 선언을 위한 별 
// 2. 역참조의 의미 (거슬러 올라간다)

//#include<stdio.h>
//int main()
//{
//
//	int a; // 일반 변수 선언
//	int* pa; //포인터 선언(주소값을 받을 수 있는 변수가 선언)
//
//	pa = &a; // 포인터에 a의 주소를 대입
//	*pa = 10; // 포인터로 변수 a에 10을 대입한다.
//	a = 20;
//
//	printf("포인터로 a값 출력 : %d\n", *pa);
//	printf("변수명으로 a값 출력 : %d", a); // 변수 a 출력
//
//}

//#include<stdio.h>
//int main()
//{
//	int i = 3000;
//	int* p = &i; //변수와 포인터 연결
//
//	printf("&i = %n\n", &i);
//	printf("p = %p\n", p);
//	printf("i = %d\n", i);//변수의 값 출력
//	printf("*p = %d", *p);//포인터를 통한 간접 참조 값 출력
//}

//포인터 사용 시 주의점
//1.

//#include<stdio.h>
//int main()
//{
//	//포인터의 타입과 변수의 타입은 일치해야 한다.
//	int i;
//	double* pd;
//	pd = &i;
//	*pd = 36.5;
//
//	printf("%f\n", pd);
//}

// 2.
//#include<stdio.h>
//int main()
//{
//	//초기화 : 변수나 배열, 구조체 등을 처음으로 값을 할당하는 것을 의미한다.
//	int* p;
//	*p = 100; //위험한 코드
//
//	printf("%d\n", *p);
//}

//3.
// 1. 포인터가 아무것도 가리키고 있지 않은 경우 NULL로 초기화
// 2. NULL 포인터를 가지고 간접 참조하면 하드웨어로 감지할 수 있다.
// 3. 포인터의 유효성 여부 판단이 쉽다.

//#include<stdio.h>
//#include<stdlib.h>
//
//int main()
//{
//	int* p_num = NULL;
//
//	if (p_num == NULL)
//	{
//		printf("포인터 변수가 NULL을 가리킵니다.\n");
//	}
//	else
//	{
//		printf("포인터 변수가 NULL을 가리지키 않습니다.\n");
//	}
//}

// scanf_s 함수는 사용자로부터 입력받을 때, 메모리 영역을 벗어나는 오류를 방지하기 위해 
// 입력값을 저장할 변수의 주소를 입력해야한다.

//#include<stdio.h>
//int main()
//{
//	int a = 10;
//	int* p_a = &a;
//	printf("a = %d", *p_a);
//}
//
//#include<stdio.h>
//int main()
//{
//	int a = 0, b = 0, temp = 0;
//	int* pa = &a;
//	int* pb = &b;
//	printf("두 수 입력 : ");
//	scanf_s("%d%d", pa, pb);
//	temp = *pa; //temp = a
//	*pa = *pb; // a = b;
//	*pb = temp; //b = temp(원래 a)
//	printf("바뀐 두 수 : %d %d", a, b);
//}

