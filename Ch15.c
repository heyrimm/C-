// 포인터와 배열의 관계

// 1. 배열의 이름은 포인터 변수 역할을 하며 배열이 시작되는 메모리의 주소를 알 수 있다. 
// 2. 그러나 배열의 이름은 값을 저장할 수는 없다. 

//#include<stdio.h>
//int main()
//{
//	int arr[3] = { 1, 2, 3 };
//	printf("%d\n", &arr[0]);
//	printf("%d\n", arr[1]);
//	printf("%d\n", arr[2]);
//
//	printf("%d\n", arr);
//}
// 만약 arr 주소 = 198178136 ~ 198178147
// arr[0] = 198178136 ~ 198178139
// arr[1] = ----40 ~ 43
// arr[2] = ----44 ~ 47

// 인덱스 번호를 통해 각 요소에 순차적으로 접근이 가능한 이유는
// 배열의 각 요소가 나란히 놓여있기 때문이다.

//#include<stdio.h>
//int main()
//{
//	int arr[3] = { 1, 2, 3 };
//	printf("첫번째 요소%d\n", &arr[0]);
//	printf("두번쨰 요소%d\n", &arr[1]);
//	printf("세번째 요소%d\n", &arr[2]);
//
//	printf("배열의 이름 : %pn", arr);
//}

//실행 결과를 보면 배열의 각 요소의 주소값은 첫번째 요소부터 4바이트씩
//증가하는 걸 알 수 있다.

// 배열의 이름은 그 자체로부터 포인터 변수의 역할을 하며, 배열이 시작하는 메모리 주소를 확인할 수 있다.

// 배열의 이름은 변수와 달리 값의 저장이 불가능한 상수(constant)형태의 포인터이다.
// 
//#include<stdio.h>
//int main()
//{
//	int a[] = { 10, 20, 30, 40, 50 };
//	int* p;
//	
//	p = a;
//
//	p[0] = 60;
//	p[1] = 70;
//	p[2] = 80;
//
//
//	printf("a[0] = %d, a[1] = %d, a[2] = %d\n", a[0], a[1], a[2]);
//	printf("p[0] = %d, p[1] = %d, p[2] = %d", p[0], p[1], p[2]);
//	
//}